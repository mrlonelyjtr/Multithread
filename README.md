# Multithread  
## Single Threaded Execution模式  
![FPp6Hg.png](https://s1.ax1x.com/2018/11/21/FPp6Hg.png)  
### 语境  
多个线程共享实例时。  
### 问题  
如果各个线程都随意地改变实例状态，实例会失去安全性。  
### 解决方案  
首先，严格地规定实例的不稳定状态的范围（临界区）。接着，施加保护，确保临界区只能被一个线程执行。这样就可以确保实例的安全性。  
### 实现  
Java可以使用synchronized来实现临界区。  
## Immutable模式  
[![FPpfCn.md.png](https://s1.ax1x.com/2018/11/21/FPpfCn.md.png)](https://imgchr.com/i/FPpfCn)  
### 语境  
虽然多个线程共享了实例，但是实例的状态不会发生变化。  
### 问题  
如果使用Single Threaded Execution模式，吞吐量会下降。  
### 解决方案  
如果实例被创建后，状态不会发生变化，建议不要使用Single Threaded Execution模式。  
为了防止不小心编写出改变实例状态的代码，修改代码，让线程无法改变表示实例状态的字段。另外，如果代码中有改变实例状态的方法（setter），删除它们。获取实例状态的方法（getter）则没有影响，可以存在于代码中。  
使用Immutable模式可以提高吞吐量。但是，在整个项目周期内持续地保持类的不可变性（immutability）是非常困难的。
### 实现  
Java可以使用private来隐藏字段。另外，还可以使用final来确保字段无法改变。  
## Guarded Suspension模式  
![FPpj81.png](https://s1.ax1x.com/2018/11/22/FPpj81.png)  
### 语境  
多个线程共享实例时。  
### 问题  
如果各个线程都随意地访问实例，实例会失去安全性。  
### 解决方案  
如果实例的状态不正确，就让线程等待实例恢复至正确的状态。首先，用“守护条件”表示实例的“正确状态”。接着，在执行可能会导致实例失去安全性的处理之前，检查是否满足守护条件。如果不满足守护条件，则让线程等待，直至满足守护条件为止。  
使用Guarded Suspension模式时，可以通过守护条件来控制方法的执行。但是，如果永远无法满足守护条件，那么线程会永远等待，所以可能会失去生存性。  
### 实现  
在Java中，可以使用while语句来检查守护条件，调用wait方法来让线程等待。接着，调用notify/notifyAll方法来发送守护条件发生变化的通知。而检查和改变守护条件则可以使用Single Threaded Execution模式来实现。  
## Balking模式  
![FPpxv6.png](https://s1.ax1x.com/2018/11/22/FPpxv6.png)  
### 语境  
多个线程共享实例时。  
### 问题  
如果各个线程都随意地访问实例，实例会失去安全性。但是，如果要等待安全的时机，响应性又会下降。  
### 解决方案  
当实例状态不正确时就中断处理。首先，用“守护条件”表示实例的“正确状态”。接着，在执行可能会导致实例失去安全性的处理之前，检查是否满足守护条件。只有满足守护条件时才让程序继续执行。如果不满足守护条件就中断执行，立即返回。  
### 实现  
Java可以使用if语句来检查守护条件。这里可以使用return语句从方法中返回或是通过throw语句抛出异常来进行中断。而检查和改变守护条件则可以使用Single Threaded Execution模式来实现。  